(*Generate Code*)
(*$Id: codegen.ml,v 1.33 2003/07/01 00:59:46 vaibhav Exp $ *)
open Ast
open Ass

let vemit s = 
  output_string !out_file_stream (s^" ") 
    
let emit_license() =
  vemit ("\n -- Generated by mv2rm DONOT edit\n");
  vemit ("-- Report bugs to <vaibhav@cse.ucsc.edu>\n")

let emit_module_name () =
  vemit ("\nmodule a_"^ !moduleName  ^ "\n")
    
let emit_io_stmts () = 
  let is_first = ref true in
  let vemit_smart s = begin
    match (Hashtbl.find symTab s) with
     Symb(_,Bool,_)  -> 
       if (!is_first) then 
	 (vemit ("\t"^ s^": (0..1)"); is_first := false)
       else
	 vemit (";\n\t"^ s^": (0..1)")
    | Symb(_, Mv(values),_) -> begin
	let is_first2 = ref true in
	let vemit2 s =
	  if (!is_first2) then (vemit s; is_first2 := false)
	  else (vemit (", "^s) )
	in	
	if (!is_first) then (
	  vemit ("\t" ^s^" : {"); 
	  List.iter vemit2 (List.tl values); vemit "}";
	  is_first := false;)
	else (
	  vemit (";\n\t" ^s^" : {"); 
	  List.iter vemit2 (List.tl values); vemit "}";
	  )	   		
    end
    | Symb(_, MvRange(range),_) -> 
	begin
	  if (!is_first) then (
	    vemit ("\t" ^ s ^ " : (0.." ^ string_of_int(range-1)^")");
	    is_first := false )
	  else
	    vemit (";\n\t"^s^" : (0.." ^ string_of_int(range-1)^")");
	end
    | _ -> raise (Failure("Unknown Error"))
  end in
  if (!refiList <> []) then begin 
    vemit "external \n"; 
    List.iter vemit_smart !refiList;
    vemit "\n"
  end;
  if (!refoList <> []) then begin
    is_first := true;
    vemit "interface \n";
    List.iter vemit_smart !refoList; 
    vemit "\n"
  end

let emit_table_io_stmts outList inList =  
  let is_first = ref true in
  let vemit_tab2 s = 
    if (!is_first) then (vemit s; is_first := false)
    else (vemit "," ; vemit s)
  in
  vemit "  controls ";
  List.iter vemit_tab2 outList;vemit "\n"; 
  if (inList <> []) then begin 
    is_first := true;
    vemit "  awaits ";
    List.iter vemit_tab2 inList;vemit "\n"
  end

let emit_update () =
  vemit "    update \n"

let emit_init () =
  vemit "    init \n"

let emit_reset_io_stmts outList inList = 
  let is_first = ref true in
  let vemit_tab2 s = 
    if (!is_first) then (vemit s; is_first := false)
    else (vemit "," ; vemit s)
  in
  vemit "  controls ";
  List.iter vemit_tab2 outList;vemit "\n"; 
  if (inList <> []) then begin
    is_first := true;
    vemit "  awaits ";
    List.iter vemit_tab2 inList;vemit "\n"
  end

let emit_reset_controlio_stmts outList inList = 
  let is_first = ref true in
  let vemit_tab2 s = 
    if (!is_first) then (vemit s; is_first := false)
    else (vemit "," ; vemit s)
  in
  vemit "  controls ";
  List.iter vemit_tab2 outList;vemit "\n"

let emit_reset_awaitio_stmts outList inList = 
  let is_first = ref true in
  let vemit_tab2 s = 
    if (!is_first) then (vemit s; is_first := false)
    else (vemit "," ; vemit s)
  in
  if (inList <> []) then begin
    is_first := true;
    vemit "  awaits ";
    List.iter vemit_tab2 inList;vemit "\n"
  end

let emit_init_update () =
  vemit "    init update \n"
      
let rec split_list_from_start (l:relation list) n =
  match l with
    []  -> []
  | hd::tl -> if (n = 1) 
  then [hd]
  else [hd]@(split_list_from_start tl (n-1))

(* FIXME Handling SETS and Ranges and Boolean Comparison*)
let emit_relations refoutList refinList relations =
  let relemit (s:relation list) = 
    match s with
      [] -> ()
    | hd::tl  -> 
	let is_first = ref true in 
	let vemit2out a b = 
	  match b with
	   False ->if (!is_first) then (vemit (a^"':= false "); 
				       is_first:=false )
          else (vemit ("; "^a^"':= false"))
	  | True ->if (!is_first) then (vemit (a^"':=true "); 
				       is_first:=false )
	  else (vemit ("; "^a^"':= true"))
	  | Cmp("0") ->if (!is_first) then (vemit (a^"':= 0 "); 
				       is_first:=false )
          else (vemit ("; "^a^"':= 0"))
	  | Cmp("1") ->if (!is_first) then (vemit (a^"':=1 "); 
				       is_first:=false )
	  else (vemit ("; "^a^"':= 1"))
	  | Hyp ->if (!is_first) then (vemit (a^"':= nondet "); 
				       is_first:=false )
          else (vemit ("; "^a^"':= nondet"))
	  (* An approximation *)
	  | _ ->if (!is_first) then (vemit (a^"':= nondet "); 
                is_first:=false )
          else (vemit ("; "^a^"':= nondet "))
	in
	if (hd=Default) then begin
	  vemit("\t [] default ->");
	  let outList = 
	    List.rev (split_list_from_start (List.rev s)
			(List.length (refoutList)) ) in 
	  is_first := true;
	  List.iter2 vemit2out (refoutList) outList;
	  vemit "\n"
	end
	else
	  begin
	    vemit "\t [] ";
	    let vemit2in a b = begin 
	      match b with
		Hyp -> 
		  if (!is_first) then (vemit ("true "); is_first:=false )
		  else (vemit ("& true "))
	      |	False ->if (!is_first) then (vemit (a^"':= false "); 
						is_first:=false )
              else (vemit ("; "^a^"':= false"))
	      | True ->if (!is_first) then (vemit (a^"':=true "); 
						is_first:=false )
	      else (vemit ("; "^a^"':= true"))
	      | Cmp("0") ->if (!is_first) then (vemit (a^"' = 0 "); 
					   is_first:=false )
              else (vemit ("& "^a^"' = 0 "))
              | Cmp("1") ->if (!is_first) then (vemit (a^"' = 1 "); 
					   is_first:=false )
              else (vemit ("& "^a^"' = 1 "))
              | Cmp(someval) ->
                 if (!is_first) then (vemit (a^"'="^someval^" "); 
                         is_first:=false )
                 else (vemit ("& "^a^"'="^someval^" "))
              | Range(lr,rr) ->
                  if (!is_first) then 
                         (vemit (a^"'>="^lr^" & "^a^"'<="^rr^" "); 
                          is_first:=false )
                  else (vemit ("& "^a^"'>="^lr^" & "^a^"'<="^rr^" "))
              (* TODO: Not and Set implementation *)
              | _ -> ()
  
            end in	 
	    begin
	      try 
		if (refinList <> []) then begin
		  let inList = 
		    split_list_from_start s (List.length (refinList)) in
		  is_first := true; 
		  List.iter2 vemit2in (refinList) inList;
		end
		else begin vemit "true " end;
		vemit ("->");
		is_first := true;
		let outList = 
		  List.rev (split_list_from_start (List.rev s)
			    (List.length (refoutList)) ) in 
		List.iter2 vemit2out (refoutList) outList
	      with Invalid_argument t ->
		vemit (t ^ " " ^ string_of_int (List.length s) ^ " " ^
		       string_of_int (List.length ((refoutList))))
	    end;
	    vemit "\n"
	  end
  in
  if (relations <> []) then begin 
    List.iter relemit relations
  end


let emit_module_end () =
  vemit "endmodule\n"
    
let emit_atom_start () =
  vemit "atom \n"
    
let emit_atom_end () =
  vemit "endatom \n"
	
let add_to_unmarked s =
  unmarked := (!unmarked)@[s]
			     
let emit_private_vars () =
  let switch = ref true in
  let vemit_mv a b =
    match b with 
      Symb(Private,Bool,_) -> begin 
	if (!switch) then begin 
	  vemit "private \n"; switch:=false;
	  vemit ("\t"^a);vemit ": (0..1)";
	end
	else begin
	  vemit (";\n\t"^a);vemit ": (0..1)";
	end
      end
    | Symb(Private,Mv(values),_) -> 
	let is_first = ref true in
	let vemit2 s =
	  if (!is_first) then (vemit s; is_first := false)
	  else (vemit (", "^s) )
	in
	if (!switch) then begin 
	  vemit "private \n"; switch:=false;
	  vemit ("\t"^a); vemit " :{"; 
	  List.iter vemit2 (List.tl values); vemit "}";
	end
	else begin
	  is_first := true;
	  vemit (";\n\t"^a); vemit " :{"; 
	  List.iter vemit2 (List.tl values); vemit "}";
	end
    |  Symb(Private, MvRange(range),_) -> 
	begin
	  if (!switch) then begin 
	    vemit "private \n"; switch:=false;
	    vemit ("\t"^a);
	    vemit (": (0.." ^ string_of_int(range-1)^")");
	  end
	  else begin
	    vemit (";\n\t"^a);
	    vemit (": (0.." ^ string_of_int(range-1)^")");
	  end	
	end
    | Symb(_,_,_) -> ()
    | _ -> raise (Failure("Unknown Variable"))
  in
  let vemit_mv2 a b = begin
    match b with 
      Symb(_,_,None) -> add_to_unmarked a; vemit_mv a b
    | Symb(_,_,_) -> vemit_mv a b
    | _ -> raise (Failure("Unknown Error"))
  end
  in	  
  Hashtbl.iter vemit_mv2 symTab;
  vemit "\n"

let emit_unmarked_atom s =
  begin
    vemit "atom\n";
    vemit ("  controls "^s^"\n");
    vemit "    update\n";
    vemit "\t [] "; vemit "true -> ";
    vemit (s^"':= nondet "); vemit "\n";
    vemit "endatom\n";
  end

let emit_hide_list name varList =
  begin
  vemit ( name ^ " := hide " );
  vemit (List.hd varList);
  try 
    let listMinusFst = List.tl varList in
    List.iter (fun var ->
      vemit( ",");
      vemit (var);
      ) listMinusFst;
    vemit ( " in b_" ^ name ^" endhide\n");
  with Not_found ->
    vemit ( " in b_" ^ name ^" endhide\n");
  end

let emit_subckt name subcktTabList= 
  if (name="") then () else begin
    let vemitList s = 
      let is_first = ref true in
      let is_second = ref true in
      let vemitPairA a b =
	if (!is_first) then (vemit (a^" ["); is_first := false)
	else begin 
	  if (!is_second) then (vemit a; is_second := false)
	  else vemit (", "^a) 
	end
      in
      let vemitPairB a b =
	if (!is_first) then (is_first := false)
	else begin 
	  if (!is_second) then (vemit b; is_second := false)
	  else vemit (", "^b) 
	end
      in
      match s with
      [("","")] -> ()
      | _  -> begin 
	  vemit "|| ";
	  List.iter2 vemitPairA 
	    (fst(List.split s)) (snd(List.split s));
	  vemit ":=";
	  is_first:=true; is_second:=true;
	  List.iter2 vemitPairB 
	  (fst(List.split s)) (snd(List.split s));
	  vemit " ]\n"
      end
    in
    match subcktTabList with
      [] ->  
         let mEntry = Hashtbl.find modelTab name in
         let hidelist = Ast.get_hidelist mEntry in
         if (hidelist != [] ) then begin
           vemit ("b_" ^ name ^ ":= a_" ^ name ^ " \n");
	   emit_hide_list name hidelist;
	 end
	 else 
           vemit (name ^ ":= a_" ^ name ^ " \n");
      | _ -> 
         let mEntry = Hashtbl.find modelTab name in
         let hidelist = Ast.get_hidelist mEntry in
         if (hidelist != [] ) then begin
           vemit ("b_" ^ name ^ ":= a_" ^ name ^ " \n");
	   List.iter vemitList (subcktTabList); 
	   vemit "\n";
	   emit_hide_list name hidelist;
	 end
	 else begin
           vemit (name ^ ":= a_" ^ name ^ " \n");
	   List.iter vemitList (subcktTabList); 
	   vemit "\n";
	end
  end
 
(*FIXME: Lilbit crufty priority algo*)
let emit_all_subckts () = 
  print_string "Emiting subckts ..\n";
  let subcktOrder = ref [] in 
  let rec order_subckt name subcktTabList =
    if (name="") then () else 
    begin
      if (List.mem name (!subcktOrder)) then () else 
      begin
	let vemitList s = 
	  let is_first = ref true in
	  let vemitPairA a b =
	    if (!is_first) then begin 
	      is_first:=false;
	      order_subckt a (Hashtbl.find subcktTab a)
	    end
	  in
	  List.iter2 vemitPairA 
	    (fst(List.split s)) (snd(List.split s));
	in
	match subcktTabList with
	  []-> subcktOrder := (!subcktOrder)@[name]
	| hd::tl -> List.iter vemitList (subcktTabList);
	    subcktOrder := (!subcktOrder)@[name] 	    
      end
    end in
  Hashtbl.iter order_subckt subcktTab;
  let emit_ordered s =
    emit_subckt s (Hashtbl.find subcktTab s) in
  List.iter emit_ordered !subcktOrder

let emit_latch_io_stmt input= begin
  vemit "  reads "; vemit input; vemit "\n";
end
    
let emit_latch_relations input output = begin
  vemit "\t [] "; vemit "true -> ";
  vemit (output^"':="^input); vemit "\n"
end
    
let emit_atoms() =
  let vemit_atom a b = begin
    match b with 
      Symb(Input,_,None) -> ()
    | Symb(_,_,None) -> emit_unmarked_atom a
    | Symb(_,_,TableAtom
	     (Controls(p),Awaits(q),Relations(r))) ->
	       begin
		 emit_atom_start ();
		 emit_table_io_stmts p q;
		 emit_init_update ();
		 emit_relations p q r;
		 emit_atom_end ();
	       end
    | Symb(_,_,ResetAtom
	     (Controls(p),Awaits(q),Relations(r))) ->
	       begin
		 emit_atom_start ();
		 emit_reset_io_stmts p q;
		 emit_init_update ();
		 emit_relations p q r;
		 emit_atom_end ();
	       end
    | Symb(_,_,LatchAtom
	     (LControls(lp),RControls(p),
	      Reads(q),Awaits(r),Relations(s))) ->
	       begin
		 emit_atom_start ();
		 emit_reset_controlio_stmts p r;
		 emit_latch_io_stmt q;
		 emit_reset_awaitio_stmts p r;
		 emit_init ();
		 emit_relations p r s;
		 emit_update ();
		 emit_latch_relations q lp;
		 emit_atom_end ();
	       end
    | Symb(_,_,SameAs(t)) -> ()
    | _ -> raise (Failure("Unknown Error"))
  end
  in	      
  Hashtbl.iter vemit_atom symTab;










